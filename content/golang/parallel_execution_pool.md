---
title: "并行执行池"
date: 2024-01-18T20:30:00+08:00
---
## 前言


### 并行

后端服务开发中，经常需要执行批处理任务。比如调用某服务的 HTTP 接口时，服务没有与此接口对应的批处理接口，对一批数据并行处理，将得到相比顺序处理成百上千倍的效率提升（取决于服务的并发性能）。

### 限制并行度

程序的并行度过高，无限制的并行不可取。在实际应用中，调用方或被调用方会存在资源限制，例如 CPU 核数，磁盘IO，网络等瓶颈，如果不对并发数做限制，程序可能出现不可预料的错误。

### Go 程

我们知道，GO 语言本身是为多核架构而设计的，使用 go 关键字就可以很方便地实现任意语句的异步执行。

```go
f() // 等待函数f返回
go f() // 在新的Go程中执行，无等待
```

Goroutine 结合 Channel（通道） 可以很方便的实现并行。

### 闭包

> A closure is a function value that references variables from outside its body.

闭包是引用了它外部的变量的方法。

在 GO 语言中，函数是一等公民。而闭包作为一种特殊的函数，同时也被很多其它语言所实现，将给我们的并行实现带来很大的便利。

### 抽象

前面提到，GO 语言本身已经可以很方便的写并行代码了，但是对 Channel 的操作以及对并行度的限制依旧是较为繁琐的操作，因此我们可以对这类问题抽象出公共库，隐藏细节方便复用。并行执行池是一簇有最大并行度限制的任务执行器，我们可以不断向执行池添加任务，它将负责管理调度 Go 程来执行这些任务。

## 实现

### 现有轮子

本着不重复实现的原则，我先在 Github 上调研类似的现有实现，搜索 golang parallel ，很惊喜的发现一个类似的项目 [buptmiao/parallel](https://github.com/buptmiao/parallel)，它的确可以很方便地并行执行批任务，同时它还实现了一个简单的 workflow，但是没有对并行度的限制，很遗憾，我们不能直接拿来使用。但是它对执行函数的注册，函数参数传入和返回值接口值得借鉴。

具体来说，它用反射来获取函数的参数和返回值规格，用户可以传入任意签名的函数和任意数量的参数以及接收任意数量返回值，同时也对 panic 提供了接口来处理，可以满足批处理的大部分需求。同时也带来了缺点：

- 用户学习曲线较陡。接口多，需要用户记忆很多的接口。
- 设计复杂。如何科学地设计这么多的接口，并且让接口表达准确、方便记忆是个有挑战的事，而接口是否科学本身也是很有争议的议题。
- 实现复杂。需要使用 Go 的反射库。

### 并行执行池

除了 reflect 方式的实现外，我们还可以通过闭包来实现。通过闭包可以打包一个函数以及它的参数和返回值，以闭包作为任务执行的最小单位。

公共库中涉及两个概念：

1. Pool
   - Pool 即并行执行池。一个程序中对一种任务定义一个全局的 Pool，可以设置最大并行度。
   - 可以向并行池中传入任务闭包，并行池将自动调度执行。
2. Parallel
   - Parallel 是一次并行操作，在 Pool 之上管理一批次的任务，提供接口等待当前批次任务执行完。

用户传入闭包时可以指定输入参数和接收返回值的变量，同时也可以使用 recover 处理 panic 。

### 总结

使用闭包提供了执行函数体、实参、返回值、panic 处理等功能，同时避免了复杂的反射实现，并提供了简洁的接口。
Github 上有相关topic：https://github.com/topics/goroutine-pool